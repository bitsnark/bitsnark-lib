import { SavedVm } from "../generator/common/saved-vm";
import { State, Register } from "../groth16/vm/state";
import { Instruction, InstrCode } from "../groth16/vm/vm";

export class Runner {
    state: State;
    success = true;
    witness: bigint[];
    hardcoded: bigint[];
    instructions: Instruction[] = [];
    current: number = 0;

    private constructor(hardcoded: bigint[], witness: bigint[]) {
        this.state = new State();
        this.witness = witness;
        this.hardcoded = hardcoded;
        this.reset();
    }

    private newRegister(value?: bigint): Register {
        const t = this.state.newRegister();
        if (value) {
            if (value < 0 || value >= 2n ** 32n) throw new Error('Invalid value');
            t.value = value;
        }
        return t;
    }

    private addWitness(value: bigint): Register {
        if (value < 0 || value >= 2n ** 32n) throw new Error('Invalid value');
        const t = this.newRegister(value);
        return t;
    }

    private hardcode(value: bigint): Register {
        if (value < 0 || value >= 2n ** 32n) throw new Error('Invalid value');
        const t = this.newRegister(value);
        t.hardcoded = true;
        return t;
    }

    private initHardcoded(hardcoded: bigint[]): Register[] {
        return hardcoded.map(n => this.hardcode(n));
    }

    private initWitness(withness: bigint[]): Register[] {
        return withness.map(n => this.addWitness(n));
    }

    private executeOne() {
        if (this.current >= this.instructions.length || !this.success) return;
        const instr = this.instructions[this.current];
        this.current++;
        const target = this.state.registers[instr.target];
        const param1 = this.state.registers[instr.params[0]];
        const param2 = this.state.registers[instr.params[1]];
        switch (instr.name) {
            case InstrCode.DATA:
                target.value = instr.data ?? 0n;
                break;
            case InstrCode.ADD:
                target.value = (param1.value + param2.value) % (2n ** 32n);
                break;
            case InstrCode.AND:
                target.value = param1.value & param2.value;
                break;
            case InstrCode.XOR:
                target.value = param1.value ^ param2.value;
                break;
            case InstrCode.NOT:
                target.value = ~param1.value;
                break;
            case InstrCode.SHR:
                target.value = param1.value >> param2.value;
                break;
            case InstrCode.ROTR:
                const n = param2.value;
                const a1 = param1.value & (2n ** n - 1n);
                target.value = (param1.value >> n) | (a1 << (32n - n));        
                break;
            case InstrCode.MOV:
                target.value = param1.value;
                break;
            case InstrCode.ASSERTEQ:
                if (this.success) this.success = param1.value === param2.value;
                break;
        }
        (this as any)[instr.name.toString()](instr.target, ...instr.params, instr.data);
    }

    //*******  PUBLIC   ********/

    static load(obj: SavedVm, witness: bigint[]): Runner {
        const runner = new Runner(
            obj.hardcoded.map((ns: string) => BigInt('0x' + ns)),
            witness);
        runner.instructions = obj.program.map((inst: Instruction) => ({
            name: inst.name,
            target: inst.target,
            params: inst.params
        }));
        runner.reset();
        return runner;
    }

    reset() {
        this.state = new State();
        this.initWitness(this.witness);
        this.initHardcoded(this.hardcoded);
        this.current = 0;
        this.success = true;
    }

    execute(stopAfter?: number) {
        stopAfter = Math.min(stopAfter ?? 2 ** 32, this.instructions.length - 1);
        while (this.current <= stopAfter && this.success) {
            this.executeOne();
        }
    }

    getSuccess() {
        return this.success;
    }

    getRegisters() {
        return this.state.registers;
    }
}
